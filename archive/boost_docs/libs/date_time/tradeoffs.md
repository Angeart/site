#トレードオフ：安定性、予測性と近似

- [全体のインデックスへ](../date_time.md)
- [Gregorianのインデックスへ](gregorian.md)
- [Posix Timeのインデックスへ](posix_time.md)


##避けられないトレードオフ
このライブラリは、ユーザが必要とするであろうすべてを提供するために最善を尽くす。しかし、どの時間ライブラリにも、できることを制限する固有の制約がある。 特に、ユーザはある特定のアプリケーションに、次の3つの能力の内どの2つが必要かを選ぶ:

- 壁掛け時計の時刻との厳密な一致
- 正確な数学, 例: 時間長の計算
- 未来の時間位置(timepoints)を取り扱う能力

あるライブラリは、3つすべてを与えると暗黙のうちに約束するかもしれない。しかし、実際にテストしてみれば、同時に2つだけが本当である。 この制限は、どんな特定のライブラリでも設計や実装の欠陥ではない;もっと正確に言えば、それは国際基準によって定義される時法系が非常に異なる結果である。 3つのケースについてそれぞれ見てみよう:

壁掛け時計の時刻との厳密な一致を望むなら、UTC あるいは地域時間のいずれかを使用しなければならない。 UTC 時刻同士の差を取って時間長(duration)を計算し、秒精度が必要な場合、2つの時間はあまり遠い未来にあってはならない。なぜなら、うるう秒が計算に影響するが、そればたったの約半年前に決定されるものだからである。 地域時間については、立法機関が思うままにDST規則を変えることができ、また(実際に)変えるので、未来の時間長(duration)計算は、いつでも異常になり得る。

壁掛け時計の未来の時間を扱いたければ、(一般的なケースで)上述と同じ理由のために、正確な時間長(durations)を計算することができないであろう。

もし未来の時間について正確な計算を必要とするなら、TAI あるいは同等の物を使わなければならないだろう。しかし、TAI から UTC あるいは地域時間への写像はうるう秒に依存すため、壁掛け時計の時間と正確には一致しないであろう。


##安定性、予測性と近似
ここに、何が起こっているのかを説明するのに役立つある基礎理論がある。 時間型が任意の抽象的なデータ型(ADT;Abstract Data Type)のように、それらの値に対する操作と一緒に1セットの値であることを忘れないで欲しい。


###安定性(Stability)
与えられた値に関連付いたビットパターンが時間とともに変化しない場合、型の表現は安定している。 不安定な表現を備えた型は、おそらく誰の役にも立たない。したがって、我々はどんな時間ライブラリにも安定した表現だけを使用するよう要求するだろう。

特定のオペランドに演算を適用する結果が時間とともに変化しない場合、型に対する演算は安定している。


###予測性(Predictability)
集合は、よく明確(well-defined)であるか不明確(ill-defined)であるか、の 2つのカテゴリーに分類される。 型が集合であるので、型をカバーするためにこれらの定義を拡張することができる。

任意の型 `T` について、値 `x` が型 `T` のメンバーかどうか決める述語 `is_member( x )` があるとする。 この述語は、`true`, `false`, あるいは `dont_know` を返すものとする。

すべての `x` について、`is_member( x )` が `true` か `false` のどちらかを返す場合、集合 `T` は **明確(well-defined)** であるという。

任意の `x` について、`is_member( x )` が `dont_know` を返す場合、集合 `T` は **不明確(ill-defined)** であるという。

それらは数学で通常使われる規則である。 しかしながら、時間型に特有な特性のために、この考察を洗練し、以下のように第3のカテゴリーを作ることは有用である:

任意の時間型 `T` について、値 `x` が `T` のメンバーかどうか決める述語 `is_member( x, t )` があるとする。 述語が評価されるとき、パラメータ `t` は時間に相当する。 `xi` それぞれに対して、以下のような時間 `ti` と値 `v` があるとする:

- `v = true` あるいは `v = false`
- `t < ti` である全ての `t` について、`is_member( xi, t )` は `dont_know` を返す
- `t >= ti` である全ての `t` について、`is_member( xi, t )` は `v` を返す

`xi` が `T` のメンバーであるかどうか「見つけ出す」とき、`ti` はこのように時間である。今、我々は時間型の3つのカテゴリーを定義することができる:

全ての `xi` について、`ti` = 負の無限大 のとき、型 `T` は **予測可能** であるという。

ある `xi` について、`ti` = 正の無限大 のとき、型 `T` は **不明確(ill-formed)** であるという。

それ以外のとき、型 `T` は **予測不能** であるという。 (これは、ある `xi` のために `ti` が有限であることを意味する)

不明確(ill-formed)な集合には実用性がほとんど無いので、これ以上は議論しない。 上記について簡単に言えば、予測可能な型は全ての値が事前に分かっているが、予測不能な型ではいくつかの値がある特定の時間になるまで分からない。


###操作の安定性
予測可能な型には2つの重要な特性がある:

- それらの要素から連続する整数への、順序を維持する写像が有る
- それらの値に対する時間長(duration)の演算は安定している

この実用上の効果は時間長(duration)の計算を単純な整数の減算で実装できるということである。 予測可能な型の例は TAI timepoints およびグレゴリオ暦の日付である。

予測できない型は正反対の特性を持っている:

- それらの要素から連続する整数への、順序を維持する写像が無い
- それらの値に対する時間長(duration)の演算は安定していない

予測できない型の例は UTC timepoints および地域時間 timepoints である。

予測不能な型の中の範囲が予測可能であり得ると示すことによって、これを少し改善することができる。また、完全にその範囲内で実行された演算は安定しているであろう。 例えば、UTC timepoints において 1970-01-01 から現在までの範囲は予測可能である。したがって、その範囲内での時間長(duration)の計算は安定しているであろう。


###近似(Approximations)
UTC と 地域時間のような重要な時間型が実際には予測不能なので、これらの制限は問題である。また、したがって、それらに対する演算は時々不安定である。しかし、実用上の問題として、地域時間で指定される将来の 2つの時間位置(timepoints)の間の時間長(duration)を計算するようなこの種の演算を実行したいことが多々ある。

このライブラリにできる最善策は、近似値(一般に可能で、大抵の用途で十分である)を提供することである。 もちろん、文書は、答えが近似値(したがって不安定である)であること、そしてエラーがどの位の大きさになり得るのか明示しなくてはならない。 多くの点で、予測不能な集合での計算は浮動小数点数の使用(結果がほぼ正確だろうと期待されるだけ)に似ている。 予測可能な集合での計算は整数の使用と似ており、そして結果が正確であると期待される。

正確な答えが要求されたり、不安定さを許容できない状況のために、ユーザがそれを明示できなければならない。 そして、ユーザが正確で安定した答えが得られないような計算を要求すれば、ライブラリは例外を投げるべきである。


***
Last modified: Wed Aug 28 17:52:03 MST 2002 by [Jeff Garland](mailto:jeff@crystalclearsoftware.com) © 2000-2002 

Japanese Translation Copyright (C) 2003 [Shoji Shinohara](mailto:sshino@cppll.jp).


