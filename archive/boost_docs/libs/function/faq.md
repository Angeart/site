#boost::function FAQ

##Q: `void` ポインタを見かけたが、これはタイプセーフなのか？
はい。 `boost::function` は `void` ポインタや、戻り値も引数もない関数ポインタを使っているが、タイプセーフだ。関数ポインタや関数オブジェクトを管理/実行する関数の中には、全ての型の情報が書き込まれている。 `void` ポインタや `void` 関数ポインタが指す本当の型を知らされてインスタンス化されるのは、これらの管理/実行用関数だけなのだ。 `void` ポインタと `void` 関数ポインタの両方が必要な理由は、オブジェクトへのポインタと `void` ポインタは互いに安全にキャストでき、異なる型の関数ポインタ同士も安全にキャストできることだ (ただし、異なる型で関数ポインタを呼び出してはならない) 。


##Q: なぜ `void` の `return` の回避手段を取っているのか？ C++ では許されているはずだ！
`void` の `return` は C++ 標準で許されている。以下はこれを使ったコードの一部だ。

```cpp
void f();
void g() { return f(); }
```

`void` の `return` を使わない理由の 1 つとして、全てのコンパイラが `void` の `return` をサポートしているわけではないことが挙げられる。実際には、このちょっとした機能をサポートするコンパイラはごく一部だ。さらに、 `void` の `return` を使わないことで、 `boost::function` はもっと柔軟になった。以下の例を考えてみよう。

```cpp
int do_something(int);

boost::function<void, int> f;
f = do_something;
```

この `boost::function` の使い方が有効なのは、 `void` の `return` が使われていないからだ。 `void` の `return` を使うと、以下のコードと同等の不正なコードをコンパイルしようとすることになる。

```cpp
int f();
void g() { return f(); }
```

`void` の `return` を使わないことで、 `boost::function` は戻り値を飲み込めるようになる、というのが本質なのだ。このことは、「ぴったり一致しないパラメータを持つ関数や関数オブジェクトを代入/実行できる」こととも一貫している。


##Q: なぜ (関数を) コピーするのか？
2000 年の 11 ～ 12 月に、コピー vs. 参照の論争が長々と繰り広げられた。その結果、コピーの方が予測しやすいセマンティクスになるという結論になった。私はここでその議論を蒸し返すつもりはない。コピーが不適当な場合は、参照カウント式アロケータを使えばよい。


***
Douglas Gregor

Last modified: Fri Oct 11 05:39:27 EDT 2002

Japanese Translation Copyright © 2003 [Hiroshi Ichikawa](gimite@mx12.freecom.ne.jp)

オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。

このドキュメントの対象: Boost Version 1.29.0

