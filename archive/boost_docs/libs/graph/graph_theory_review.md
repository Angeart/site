#基本的なグラフ理論の復習
この章は、基本的なグラフ理論を思い出させることを意図している。読者があらかじめグラフアルゴリズムの知識があるのなら、始めるにあたりこの章は十分であろう。もし読者がグラフアルゴリズムの知識がないのならば、 Cormen, Leiserson, Rivestの[Introduction to Algorithms](http://www.toc.lcs.mit.edu/~clr/) のようなもっと詳しいものを薦める。


##グラフ抽象
グラフは、多くの種類の問題を解くのに有効な数学的抽象化である。基本的には、グラフは頂点と辺から構成され、辺は二つの頂点を結ぶ。もっと正確には、グラフ(graph)とは組`(V,E)`で表され、`V`は有限集合で、`E`は`V`の２項関係である。`V`は **頂点集合(vertex set)** と呼ばれ、その要素を **頂点(vertex)** と呼ぶ。`E`は辺の集合で、 **辺(edge)** とは`(u,v)`の組で`u`、`v`は`V`の要素である。 **有向グラフ(directed graph)** においては、辺は順序付けられた組で、 **始点(source)** を **終点(target)** へと接続する。無向グラフ(undirected graph)においては、辺は順序付けされていない組で、２つの頂点を両方向につなぐ。つまり、無向グラフでは `(u,v)`と`(v,u)`は同じ辺の２通りの書き方である。

グラフのこの定義は、いくつかの点であいまいである。辺や頂点が何を表現するかが述べられていない。グラフの例としては、連絡道路やハイパーリンク付きのウェブページなどを挙げることができる。これらの詳細がグラフの定義からは除外されているのは、大きな理由がある。それらの詳細はグラフの **抽象化** の中では必要な部分ではない。詳細を定義から除外することで再利用可能な理論を構築でき、そのことは多くの異なった種類の問題を解く際に役に立つのである。

定義にもどろう。グラフは頂点と辺の集合である。実際の様子を見せるため、頂点に文字のラベルがついたグラフを考え、辺を単純に文字の組としよう。ここで、有向グラフの例を次のように書くことができる。

```
V = {v, b, x, z, a, y } 
E = { (b,y), (b,y), (y,v), (z,a), (x,x), (b,x), (x,v), (a,z) } 
G = (V, E)
```

このグラフを図示すると 図1 のようになる。辺 `(x,x)` は **輪(self-loop)** と呼ばれる。`(b,y)`と `(b,y)`は **平行辺(parallel edges)** であり、これは **マルチグラフ(multigraph)** でのみ許される(ただし、通常は有向グラフでも無向グラフでも許されない)。


![](http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/digraph.gif)

図1: 有向グラフの例


次に似たようなグラフを示すが、今度は無向グラフである。これは図2に図示する。無向グラフでは輪は許されない。上記のグラフ(から平行辺`(b,y)`を除いたもの)の **無向版(undirected version)** である。それはつまり、同じ頂点をもち、同じ辺から方向を除いたものを持つことを意味し、`(a,z)`と`(z,a)`という２つの辺は一つの辺に退化する。また、逆を考えることもできる。無向グラフの **有向版(directed version)** は、すべての辺をそれぞれの方向を向く２つの辺で置き換えることで得られる。

```
V = {v, b, x, z, a, y }
E = { (b,y), (y,v), (z,a), (b,x), (x,v) }
G = (V, E)
```

![](http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undigraph.gif)

図2: 無向グラフの例

ここでさらにグラフの用語を定義する。辺`(u,v)`がグラフに含まれるとき、頂点`v`は頂点`u`について **隣接している(adjacent)** と言う。有向グラフでは、辺`(u,v)`は 頂点`u`の **出辺(out-edge)** であり、頂点`v`の **入辺(in-edge)** である。無向グラフでは、辺`(u,v)`は頂点`u`と`v`を **接合している(incident on)** という。

図1で、頂点`y`は頂点`b`に対して隣接している (ただし`b`は`y`に対して隣接していない)。辺`(b,y)`は`b`の出辺であり、`y`の入辺である。図2で、`y`は`b`に隣接していて、また逆も同様である。辺`(y,b)`は頂点`y`と`b`を接合している。

有向グラフにおいて、ある頂点の出辺の数は **出次数(out-degree)** と呼ばれ、入辺の数は **入次数(in-degree)** と呼ばれる。無向グラフにおいて、ある頂点に対して接合している辺の数は **次数(degree)** と呼ばれる。図1で、頂点`b`の出次数は3であり、入次数は0である。図2では単純に頂点`b`の次数は2である。

グラフの **路(path)** とは辺の列で、それぞれの辺の終点が次の辺の始点であるものである。頂点`u`から始まり頂点`v`で終わる路があれば、頂点`v`は`u`から **到達可能(reachable)** であるという。路が **単純(simple)** であるとは、辺の列の中でどの頂点も繰り返し現れないことである。路`<(b,x), (x,v)>`は単純であるが、路`<(a,z), (z,a)>`は単純ではない。また、路`<(a,z), (z,a)>`は最初の頂点と最後の頂点が一致するので、 **サイクル(cycle)** と呼ばれる。サイクルのないグラフは **アサイクリック(acyclic)** と呼ばれる。

**平面的グラフ(planar graph)** とは、すべての辺が交差しないように平面上に描けるグラフのことである。そのように描かれたものは **平面グラフ(plane graph)** と呼ばれる。平面グラフの **面(face)** とは、辺に囲まれた連結成分のことである。平面的グラフの重要な特性は、面、辺、頂点の数がオイラーの定理：`|F| - |E| + |V| = 2`によって関係付けられることである。このことは、平面的グラフは最大でもO(|V|)個の辺しか持たないことを意味する。


##グラフデータ構造
データ構造を考えるときに最初に考えるべきグラフの属性は、**まばらさ(sparsity)** である。まばらさとは、頂点に対する相対的な辺の数である。`E`が`V²`に近いグラフは **密(dense)** であると呼ばれ、`E = alpha V`で`alpha`が`V`より十分に小さい場合は、まばらな(sparse)グラフと呼ばれる。密なグラフについては、通常、 **隣接行列表現(adjacency-matrix representation)** が最良の選択であり、一方まばらなグラフについては **隣接リスト表現(adjacency-list representation)** が最良である。また、まばらなグラフについては **辺リスト表現(edge-list representation)** も適切な状況下では記憶効率面でよい選択である。


###隣接行列表現
グラフの隣接行列表現はV x Vの２次元配列である。 行列a<sub>uv</sub>の要素は、辺`(u,v)`がグラフに含まれるかどうかを示すブーリアン値である。図3に図1(から`(b,y)`を引いたもの)の隣接行列表現を表す。保存に必要な領域はO(V²)である。任意の辺について、アクセス、追加、除去にかかる時間はO(1)である。 頂点の追加や除去は、再割り当てとすべてのグラフのコピーが必要になり、手順数はO(V²)になる。[`adjacency_matrix`](./adjacency_matrix.md)クラスは、隣接行列表現によってBGLグラフインターフェースを実装する。

![](http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_matrix.gif)

図3: 隣接行列によるグラフの表現


###隣接リスト表現
グラフの隣接リスト表現では、すべての頂点に対して出辺の列を保存する。まばらなグラフでは、こうすることでメモリ領域を節約でき、必要な領域はO(V + E)だけになる。さらに、すべての頂点の出辺にはより効果的にアクセスできる。辺の挿入のコストはO(1)で、任意の辺へのアクセスはO(alpha)である。ここで、alphaは行列のまばらさ(グラフ中のすべての頂点についての出辺の数の最大値)である。図4は図1のグラフの隣接リスト表現である。[`adjacency_list`](./adjacency_list.md)は隣接リスト表現の実装である。

![](http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_list.gif)

図4: 隣接リストによるグラフ表現


###辺リスト表現
グラフの辺リスト表現は、単純に辺の列であり、辺は頂点のIDの組で表される。必要なメモリはO(E)だけである。辺挿入のコストはO(1)であり、特定の辺のアクセスするのはO(E)(あまり効果的でない)である。図5は図1のグラフの辺リスト表現である。[`edge_list`](./edge_list.md)アダプタクラスは、辺リスト表現の実装を作るのに使うことができる。

![](http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/edge_list.gif)

図5: 辺リストによるグラフの表現


##グラフアルゴリズム
###グラフ探索アルゴリズム
###幅優先探索
###深さ優先探索

##最小全域木問題

##最短経路問題

##ネットワークフロー問題


***
Copyright © 2000-2001 [Jeremy Siek](http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm), Indiana University (<jsiek@osl.iu.edu>)

Japanese Translation Copyright © 2014 [Akira Takahashi](faithandbrave@gmail.com)

オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。

