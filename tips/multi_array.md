#多次元配列

Contents
<ol class='goog-toc'><li class='goog-toc'>[<strong>1 </strong>概要](#TOC--)</li><li class='goog-toc'>[<strong>2 </strong>部分配列の走査](#TOC--1)</li></ol>


<h4>概要</h4>boost::multi_arrayクラスはCスタイル多次元配列特有の分かりにくさを解消し、様々な走査を提供する。ただし、boost::arrayとは違いオーバーヘッドが存在するため注意が必要である。<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>#include <iostream></code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>#include <boost/multi_array.hpp></code><br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>int main()</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>{</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    // Cスタイル (3x4x5 ? それとも 5x4x3 ?)</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    int C_style[3][4][5];</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    C_style[0][0][0] = 0; // ok</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    C_style[4][3][2] = 0; // これは正しい？ (非常に分かりにくいが、境界の外に書き込もうとしている</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    C_style[2][3][4] = 0; // こちらは正しい</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    typedef boost::multi_array<int, 3> three_dim_array;</code><br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    // Boost.MultiArray (3x4x5)</code><code style='color:rgb(0,0,0)'>    three_dim_array Boost_style(boost::extents[3][4][5]);</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    Boost_style[0][0][0] = 0; // ok</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    Boost_style[4][3][2] = 0; // 境界の外に書き込もうとしたので例外が投げられる</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    Boost_style[2][3][4] = 0; // ok</code><code style='color:rgb(0,0,0)'>    // Boost.MultiArray (3x4x5)</code><code style='color:rgb(0,0,0)'>    boost::array<int, 3> shape = {{ 3,4,5 }};</code><code style='color:rgb(0,0,0)'>    three_dim_array Another_style(shape); // 3,4,5で初期化されるわけではないことに注意されたい</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>}</code>
<b>テンプレート引数</b>boost::multi_arrayは第1テンプレート引数に要素の型、第2テンプレート引数に次元数を、第3テンプレート引数にアロケータをとる。通常、アロケータはデフォルトテンプレート引数をそのまま用いればよい。<b>初期化</b>boost::multi_arrayはboost::extentsなどによって各次元の次元長を設定するか、部分配列、ビューを用いて初期化することが可能である。<h4>部分配列の走査</h4>boost::multi_arrayはCスタイルの配列では難しい部分配列への走査を提供している。```cpp
<code style='color:rgb(0,0,0)'>#include <iostream></code><br style='color:rgb(0,0,0)'/>`#include <boost/multi_array.hpp><br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/>int main()<br style='color:rgb(0,0,0)'/>{<br style='color:rgb(0,0,0)'/>    typedef boost::multi_array<int, 2> matrix_t;<br style='color:rgb(0,0,0)'/>    matrix_t matrix(boost::extents[5][5]);<br style='color:rgb(0,0,0)'/>    for (int i=0; i<5; ++i)<br style='color:rgb(0,0,0)'/>        for (int j=0; j<5; ++j)<br style='color:rgb(0,0,0)'/>            matrix[i][j] = i*j;<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/>    typedef matrix_t::<span style='color:rgb(255,0,0)'>index_range         range;</span><br style='color:rgb(0,0,0)'/>    typedef matrix_t::<span style='color:rgb(255,0,0)'>array_view<1>::type view_t</span>;<br style='color:rgb(0,0,0)'/>    view_t view = matrix[ <span style='color:rgb(255,0,0)'>boost::indices[range(1,4)][3] ];</span><br style='color:rgb(0,0,0)'/>    for (int i=0; i<3; ++i)<br style='color:rgb(0,0,0)'/>        std::cout << "matrix[" << (i + 1) << "][3] = " << view[i] << std::endl;}`
実行結果：```cpp
<code style='color:rgb(0,0,0)'>matrix[1][3] = 3</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>matrix[2][3] = 6</code><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>matrix[3][3] = 9</code>
