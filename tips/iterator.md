#イテレータを作る
Boost.Iteratorを用いると、イテレータをより楽に作成できる。
Contents
<ol class='goog-toc'><li class='goog-toc'>[<strong>1 </strong>イテレータの作成（iterator_facade）](#TOC-iterator_facade-)</li><li class='goog-toc'>[<strong>2 </strong>イテレータの種類と要求される関数](#TOC--)</li><li class='goog-toc'>[<strong>3 </strong>より楽にイテレータを作成するためのiterator_adaptor](#TOC-iterator_adaptor)</li></ol>


<h4>イテレータの作成（iterator_facade）</h4>boost::iterator_facadeはイテレータを作成するためのテンプレートクラスである。このクラスを継承して必要な関数を書くとtypedefや演算子が自動的に定義される。boost::iterator_facedeのテンプレート引数には順に以下のように取る。=boost::use_defaultの引数はデフォルトでboost::use_defaultが指定されていることを示す。
- iterator_facedeを継承するクラスの名前
- イテレータのvalue_typeとなる型
- イテレータの種類を示すタグ　（=boost::use_default）
- イテレートするための変数の参照型　（=boost::use_default）
- イテレータ間の距離を示すための型　（=boost::use_default）また、boost::iterator_core_accessをfriendクラスにして、指定したイテレータの種類によって要求されている関数を定義する必要がある。例```cpp
<code style='color:rgb(0,0,0)'>#include <iostream><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>#include <algorithm><code style='color:rgb(255,0,0)'>#include <boost/iterator/iterator_facade.hpp><code style='color:rgb(0,0,0)'>#include <boost/shared_ptr.hpp><br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>// よくある単方向リストがあったとする<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>struct my_list_node<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>{<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    int data;<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    boost::shared_ptr<my_list_node> next;<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>};<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>typedef boost::shared_ptr<my_list_node> my_list;<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>// 0から100までの値が入った単方向リストを作る<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>my_list create_list()<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>{<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    my_list root( new my_list_node );<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    root->data = 0;<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    my_list p = root;<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    for( int i = 1; i <= 100; ++i ) {<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>        p->next = my_list( new my_list_node );<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>        p->next->data = i;<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>        p = p->next;<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    }<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    return root;<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>}<br style='color:rgb(0,0,0)'/><br style='color:rgb(255,0,0)'/><code style='color:rgb(255,0,0)'>// my_list用のイテレータを作る<code style='color:rgb(0,0,0)'>class my_list_iterator :<br style='color:rgb(0,0,0)'/>    public boost::iterator_facade<<span>        my_list_iterator,         int,        boost::forward_traversal_tag></span><code style='color:rgb(0,0,0)'>{<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    boost::shared_ptr<my_list_node> p_;<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>public:<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    my_list_iterator()<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    { }<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    explicit my_list_iterator(boost::shared_ptr<my_list_node> p) :<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>        p_( p )<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    { }<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>private:    friend class boost::iterator_core_access;    void increment() { p_ = p_->next; }    int& dereference() const { return p_->data; }    bool equal(const my_list_iterator& other) const { return p_ == other.p_; }<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>};<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>my_list_iterator begin(my_list& p)<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>{<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    return my_list_iterator( p );<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>}<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>my_list_iterator end(my_list&)<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>{<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    return my_list_iterator();<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>}<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>void print(int value)<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>{<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    std::cout << value << " ";<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>}<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>int main()<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>{<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    my_list root = create_list();        // よくあるイテレータを使ったループ    for( my_list_iterator itr = begin( root ); itr != end( root ); ++itr ) {<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>        std::cout << *itr << " ";<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    }<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    std::cout << std::endl;    // もちろんアルゴリズムも可    std::for_each( begin( root ), end( root ), &print );<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>    std::cout << std::endl;<br style='color:rgb(0,0,0)'/><code style='color:rgb(0,0,0)'>}
<h4>イテレータの種類と要求される関数</h4>
<b>イテレータの種類とそのイテレータで要求される関数の一覧</b>
```

| | | | | | | |
|---------------------------|------------|------|----------|----------|--------|------------|
|  | dereference | equal | increment | decrement | advance | distance_to |
|incrementable_traversal_tag | O |  |O  |  |  |  |
|single_pass_traversal_tag | O | O |O  |  |  |  |
|forward_traversal_tag |O  |O  | O |  |  |  |
|bidirectional_traversal_tag | O | O |O  |O  |  |  |
|random_access_traversal_tag |O  | O | O | O |O  | O |

Forward Traversal Iterators（forward_traversal_tagで表されるイテレータ）はSingle Pass Iterators　（single_pass_traversal_tagで表されるイテレータ）の要求に加えて、イテレータについてデフォルトコンストラクタが要求される。

<h4>より楽にイテレータを作成するためのiterator_adaptor</h4>
boost::iterator_facadeでは、要求される関数を自分で定義しなければならない。boost::iterator_facadeは柔軟ではあるが、決まったパターンを書くのは面倒である。例えば、既存のイテレータやポインタを用いてイテレータを作成する場合はイテレータやポインタを変数と要求される関数をいちいち書かなければならないことがそれに当たるだろう。そこで、boost::iterator_adaptorを使えば、あらかじめ既存のイテレータやポインタを変数に持っており要求される関数が定義されているイテレータのクラスを作ることができる。

端的に言えば、boost::iterator_adaptorはboost::iterator_facadeを継承していてイテレートするための変数とイ要求する関数が定義されているクラスである。
boost::iterator_adaptorのテンプレート引数は順に以下のように取る。=boost::use_defaultの引数はデフォルトでboost::use_defaultが指定されていることを示す。
- iterator_facedeを継承するクラスの名前　
- イテレートするための変数の型
- イテレータのvalue_typeとなる型　（=boost::use_default)
- イテレータの種類を示すタグ　（=boost::use_default)
- イテレートするための変数の参照型　（=boost::use_default)
- イテレータ間の距離を示すための型　（=boost::use_default)イテレートするための変数をデリファレンスした型がイテレータのvalue_typeとなる型と一致する場合は、boost::use_defaultが使うこと出来る。例えば、イテレートするための変数の型がint *で、デリファンレスした時の型がintの場合がそれにあたる。また、イテレートするための変数が既存のイテレータやポインタの場合、イテレータの種類を示すタグをboost::use_defaultにすることが出来る。
boost::iterator_adaptorでは、increment関数やdecrement関数などの要求される関数があらかじめ定義されているが、boost::iterator_core_accessをfriendクラスにしてincrement関数などの要求される関数を書くことによって動作をカスタマイズできる。また、このときboost::iterator_adaptorのprotectedメンバであるbase関数やbase_reference関数を使うことで指定した既存ノイテレータやポインタなどのオブジェクトにアクセスして操作できる。


例
```cpp
`#include <iostream><br style='color:rgb(0,0,0)'/>#include <algorithm>#include <boost/iterator_adaptors.hpp>class container<br style='color:rgb(0,0,0)'/>{<br style='color:rgb(0,0,0)'/>    int values_[100];<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/>public:<br style='color:rgb(0,0,0)'/>    struct iterator :<br style='color:rgb(0,0,0)'/>        public boost::iterator_adaptor<iterator, int *>    {<br style='color:rgb(0,0,0)'/>        iterator(int *p) :<br style='color:rgb(0,0,0)'/>            iterator::iterator_adaptor_( p )        { }<br style='color:rgb(0,0,0)'/>    };<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/>    container()<br style='color:rgb(0,0,0)'/>    {<br style='color:rgb(0,0,0)'/>        for( int i = 0; i < 100; ++i ) {<br style='color:rgb(0,0,0)'/>            values_[i] = i;<br style='color:rgb(0,0,0)'/>        }<br style='color:rgb(0,0,0)'/>    }<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/>    iterator begin()<br style='color:rgb(0,0,0)'/>    { return iterator( values_ ); }<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/>    iterator end()<br style='color:rgb(0,0,0)'/>    { return iterator( values_ + 100 ); }<br style='color:rgb(0,0,0)'/>};<br style='color:rgb(0,0,0)'/><br style='color:rgb(0,0,0)'/>int main()<br style='color:rgb(0,0,0)'/>{<br style='color:rgb(0,0,0)'/>    container c;<br style='color:rgb(0,0,0)'/>    for( container::iterator itr = c.begin(); itr != c.end(); ++itr ) {<br style='color:rgb(0,0,0)'/>        std::cout << *itr << " ";<br style='color:rgb(0,0,0)'/>    }<br style='color:rgb(0,0,0)'/>    std::cout << std::endl;<br style='color:rgb(0,0,0)'/>}`
